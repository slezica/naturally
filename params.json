{"body":"## Let me show you\r\nSay we have this rather unoriginal XML document:\r\n```xml\r\n<?xml version=\"1.0\"?>\r\n<catalog version=\"2.1\">\r\n    <book id=\"1\"\r\n          title=\"The Divine Comedy\"\r\n          author=\"Danti Alighieri\">\r\n          \r\n          <edition date=\"2002-10\" language=\"italian\" />\r\n          <edition date=\"2003-05\" language=\"english\" />\r\n          \r\n          <description>\r\n              An epic poem that describes Dante's travels through Hell, Purgatory, and Heaven\r\n          </description>\r\n      </book>\r\n      \r\n    <book id=\"2\"\r\n          title=\"The Stranger\"\r\n          author=\"Albert Camus\"\r\n          date=\"1942\">\r\n          \r\n          <edition date=\"2007-04\" language=\"french\"  />\r\n          <edition date=\"2010-03\" language=\"spanish\" />\r\n          \r\n          <description>\r\n            The story of Meursault, an Algerian who seemingly irrationally kills an Arab man whom he recognises in French Algiers.\r\n          </description>\r\n      </book>\r\n</catalog>\r\n```\r\n\r\n## Reading XML\r\nTo tinker with `naturally`, you can fire the `demo.py` script.\r\n```\r\n$ python demo.py\r\n```\r\n\r\nThis will land you into an interactive shell with the first command already ran for you:\r\n```python\r\n>>> catalog = naturally.xml('demo.xml')\r\n>>>\r\n```\r\n\r\nNow, XML documents are _naturally_ represented as python objects acting as both a dictionary of their attributes, and a container for their children. \r\n```python\r\n>>> catalog['version']\r\n'2.1'\r\n>>> catalog.book[0]['id']\r\n'1'\r\n```\r\n\r\nIn JQuery-style, nodes and sequences of nodes are handled in a mostly transparent manner.\r\n```python\r\n>>> catalog.book['id']\r\n['1', '2']\r\n```\r\n\r\nFiltering is _naturally_ easy as well. Using the `()` operator, you can demand presence or specific values of attributes.\r\n```python\r\n>>> catalog.book('date')['title']\r\n'The Stranger'\r\n>>> catalog.book(id='1')['author']\r\n'Danti Alighieri'\r\n```\r\n\r\nSince the object's namespace is enterily dedicated to represent the underlying XML document, you can't access some of the data directly. Instead, call the object as if using an empty filter: this will give you the underlying Element nodes, properly represented. \r\n\r\n```python\r\n>>> catalog.book.description()\r\n[<Element 'description' at 0x235e350>, <Element 'description' at 0x235e4d0>]\r\n>>> catalog.book(id='1').description().text.strip()\r\n\"An epic poem that describes Dante's travels through Hell, Purgatory, and Heaven\"\r\n```\r\n\r\nFeels natural, right?\r\n\r\n# Writing XML\r\nI have not yet implemented XML creation, but I intend to heavily use [autovivification](http://en.wikipedia.org/wiki/Autovivification) to make it as dead simple as reading. Stay tuned.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Naturally","tagline":"as if XML documents were just made of Python"}